"""
module activitymanager\n
A non-class module to deal with the "activities" table in the database\n
Created by Abigail Franz on 2/25/2018\n
Last modified by Abigail Franz on 3/2/2018
"""

import sqlite3
from datetime import datetime, timedelta, MAXYEAR
from common import DB_PATH, WC_FORMAT

def create_activities_if_dne():
	"""
	Create the activities table in the database if it does not already exist.
	Return True if the operation is successful, regardless of whether or
	not the table has to be created.
	"""
	query = '''
		CREATE TABLE IF NOT EXISTS activities(
			id INTEGER PRIMARY KEY,
			activity_id INTEGER,
			start_time TEXT,
			end_time TEXT,
			expiration TEXT,
			user_id INTEGER NOT NULL, 
				FOREIGN KEY (user_id) REFERENCES users(id))
	'''
	db = sqlite3.connect(DB_PATH)
	try:
		cursor = db.cursor()
		cursor.execute(query)
		db.commit()
		return True
	except Exception as e:
		db.rollback()
		print(format("Couldn't create table activities. Message: %s" % (e,)))
		return False
	finally:
		db.close()

def activity_exists(activity_id):
	"""
	Determine if an activity exists in the database given its WEconnect ID.
	"""
	db = sqlite3.connect(DB_PATH)
	try:
		cursor = db.cursor()
		query = '''SELECT * FROM activities WHERE activity_id=? LIMIT 1'''
		cursor.execute(query, (activity_id,))
		activity = cursor.fetchone()
		if activity == None:
			return False
		else:
			return True
	except Exception as e:
		print(format("Couldn't determine if activity exists. Message: %s" % (e,)))
		return None
	finally:
		db.close()

def extract_params(activity):
	"""
	Given a JSON activity object from WEconnect, extract the important
	parameters (start time, end time, and expiration date).
	"""
	# Determines the start and end times
	ts = datetime.strptime(activity["dateStart"], WC_FORMAT)
	te = ts + timedelta(minutes=activity["duration"])

	# Determines the expiration date (if any)
	expiration = datetime(MAXYEAR, 12, 31)
	if activity["repeat"] == "never":
		expiration = te
	if activity["repeatEnd"] != None:
		expiration = datetime.strptime(activity["repeatEnd"], WC_FORMAT)

	return ts, te, expiration

def update_activity(activity_id, start_time, end_time, expiration):
	"""
	Update an activity's fields if the user has changed it. Return True if
	successful.
	"""
	query = '''
		UPDATE activities
		SET start_time=?, end_time=?, expiration=?
		WHERE activity_id=?
	'''
	db = sqlite3.connect(DB_PATH)
	try:
		cursor = db.cursor()
		cursor.execute(query, (start_time, end_time, expiration, activity_id))
		db.commit()
		return True
	except Exception as e:
		db.rollback()
		print(format("Couldn't update activity. Message: %s" % (e,)))
		return False
	finally:
		db.close()

def do_insert_activity(user_id, activity_id, start_time, end_time, expiration):
	"""
	Actually insert the activity into the database. Called by insert_activity.
	"""
	query = '''
		INSERT INTO activities(activity_id, start_time, end_time, expiration, 
				user_id)
		VALUES(?, ?, ?, ?, ?)
	'''
	params = (
		activity_id, 
		str(start_time), 
		str(end_time), 
		str(expiration), 
		user_id
	)
	db = sqlite3.connect(DB_PATH)
	db.row_factory = sqlite3.Row
	try:
		cursor = db.cursor()
		cursor.execute(query, params)
		db.commit()
		return True
	except Exception as e:
		db.rollback()
		print(format("Couldn't add activity. Message: %s" % (e,)))
		return False
	finally:
		db.close()

def insert_activity(user_id, activity):
	"""
	Insert new activity row into the database if it doesn't already exist and
	is not expired. If it exists but has been updated, update it in the
	database. Param "activity" is JSON object returned from WEconnect API
	endpoint. Return True if activity was inserted or updated and False if it 
	was not.
	"""
	# Determines the start and end times and expiration date (if any)
	st, et, expiration = extract_params(activity)
	act_id = activity["activityId"]

	# Boolean indicating whether or not the activity was inserted/updated
	status = False

	# Ignores the activity if it's already expired
	if expiration <= datetime.now():
		status = False
	else:
		# If the activity already exists in the database, sees if it's been
		# modified recently. If yes, updates it. If not, ignores it.
		if activity_exists(act_id):
			modified = datetime.strptime(activity["dateModified"], WC_FORMAT)
			if modified >= datetime.now() - timedelta(days=1):
				status = update_activity(act_id, st, et, expiration)
			else:
				status = False
		else:
			# If the activity doesn't exist in the database, adds it.
			status = do_insert_activity(user_id, act_id, st, et, expiration)

	return status

def get_activities(user_id=None):
	"""
	If no parameters are specified, return all the activities in the database.
	If user_id is specified, return all the activities for that user. If there
	are no activities or an error occurs, return an empty list.
	"""
	db = sqlite3.connect(DB_PATH)
	db.row_factory = sqlite3.Row
	try:
		cursor = db.cursor()
		if user_id != None:
			query = '''SELECT * FROM activities WHERE user_id=?'''
			cursor.execute(query, (user_id,))
		else:
			query = '''SELECT * FROM activities'''
			cursor.execute(query)
		activities = cursor.fetchall()
		return activities if activities != None else []
	except Exception as e:
		print(format("Couldn't retrieve activities. Message: %s" % (e,)))
		return []
	finally:
		db.close()

def get_users_with_current_activities():
	"""
	Get a list of all the IDs belonging to users who have activities starting
	or ending within the next 15 minutes.
	"""
	user_ids = []
	now = datetime.now().time()
	activities = get_activities()
	for activity in activities:
		st = datetime.strptime(activity["start_time"], "%Y-%m-%d %H:%M:%S")
		et = datetime.strptime(activity["end_time"], "%Y-%m-%d %H:%M:%S")
		margin = timedelta(minutes=15)
		if (st - margin).time() <= now and now <= (et + margin).time():
			print(activity["user_id"])
			if not activity["user_id"] in user_ids:
				user_ids.append(activity["user_id"])
	return user_ids

def delete_activity(id):
	"""
	Remove the activity with the given ID from the database.
	"""
	query = '''
		DELETE FROM activities WHERE EXISTS(
			SELECT * FROM activities WHERE id=?)
	'''
	db = sqlite3.connect(DB_PATH)
	try:
		cursor = db.cursor()
		cursor.execute(query, (id,))
		return True
	except Exception as e:
		print(format("Couldn't delete the activity with id=%d. Message: %s" 
			% (id, e)))
		return False
	finally:
		db.close()