"""
module activitymanager\n
A non-class module to deal with the "activities" table in the database\n
Created by Abigail Franz on 2/25/2018\n
Last modified by Abigail Franz on 2/28/2018
"""

import sqlite3
from datetime import datetime, timedelta, MAXYEAR
from common import DB_PATH

DT_FORMAT = "%Y-%m-%dT%H:%M:%S.%fZ"

def create_activities_if_dne():
	"""
	Create the activities table in the database if it does not already exist.
	"""
	query = '''CREATE TABLE IF NOT EXISTS activities(
				  id INTEGER PRIMARY KEY,
				  activity_id INTEGER,
				  start_time TEXT,
				  end_time TEXT,
				  expiration TEXT,
				  user_id INTEGER NOT NULL, 
					FOREIGN KEY (user_id) REFERENCES users(id))'''
	db = sqlite3.connect(DB_PATH)
	db.row_factory = sqlite3.Row
	try:
		cursor = db.cursor()
		cursor.execute(query)
		db.commit()
		return True
	except Exception as e:
		db.rollback()
		print(format("Couldn't create table activities. Message: %s" % (e,)))
		return False
	finally:
		db.close()

def activity_exists(activity_id):
	"""
	Determine if an activity exists in the database given its WEconnect ID.
	"""
	db = sqlite3.connect(DB_PATH)
	try:
		cursor = db.cursor()
		query = '''SELECT * FROM activities WHERE activity_id=? LIMIT 1'''
		cursor.execute(query, (activity_id,))
		activity = cursor.fetchone()
		if activity == None:
			return False
		else:
			return True
	except Exception as e:
		print(format("Couldn't determine if activity exists. Message: %s" % (e,)))
		return None
	finally:
		db.close()

def extract_params(activity):
	# Determines the start and end times
	ts = datetime.strptime(activity["dateStart"], DT_FORMAT)
	te = ts + timedelta(minutes=activity["duration"])

	# Determines the expiration date (if any)
	expiration = datetime(MAXYEAR, 12, 31)
	if activity["repeat"] == "never":
		expiration = te
	if activity["repeatEnd"] != None:
		expiration = datetime.strptime(activity["repeatEnd"], DT_FORMAT)

	return ts, te, expiration

def update_activity(activity_id, start_time, end_time, expiration):
	query = '''
		UPDATE activities
		SET start_time=?, end_time=?, expiration=?
		WHERE activity_id=?
	'''
	db = sqlite3.connect(DB_PATH)
	db.row_factory = sqlite3.Row
	try:
		cursor = db.cursor()
		cursor.execute(query, (start_time, end_time, expiration, activity_id))
		db.commit()
		return True
	except Exception as e:
		db.rollback()
		print(format("Couldn't update activity. Message: %s" % (e,)))
		return False
	finally:
		db.close()

def do_insert_activity(user_id, activity_id, start_time, end_time, expiration):
	query = '''
		INSERT INTO activities(activity_id, start_time, end_time, expiration, 
				user_id)
		VALUES(?, ?, ?, ?, ?)
	'''
	params = (
		activity_id, 
		str(start_time), 
		str(end_time), 
		str(expiration), 
		user_id
	)
	db = sqlite3.connect(DB_PATH)
	db.row_factory = sqlite3.Row
	try:
		cursor = db.cursor()
		cursor.execute(query, params)
		db.commit()
		return True
	except Exception as e:
		db.rollback()
		print(format("Couldn't add activity. Message: %s" % (e,)))
		return False
	finally:
		db.close()

def insert_activity(user_id, activity):
	"""
	Insert new activity row into the database if it doesn't already exist and
	is not expired.	Return Boolean indicating success. Param "activity" is JSON
	returned from WEconnect API endpoint.
	"""
	# Determines the start and end times and expiration date (if any)
	st, et, expiration = extract_params(activity)
	act_id = activity["activityId"]

	# Ignores the activity if it's already expired
	if expiration <= datetime.now():
		return False

	# If the activity already exists in the database, sees if it's been
	# modified recently. If yes, updates it. If not, ignores it.
	if activity_exists(act_id):
		modified = datetime.strptime(activity["dateModified"], DT_FORMAT)
		if modified >= datetime.now() - timedelta(days=1):
			update_activity(user_id, activity)
			return True
		else:
			return False

	# If the activity doesn't exist in the database, adds it.
	do_insert_activity(user_id, act_id, st, et, expiration)
	return True

def get_activities(user_id=None):
	"""
	If no parameters are specified, return all the activities in the database.
	If user_id is specified, return all the activities for that user.
	"""
	db = sqlite3.connect(DB_PATH)
	db.row_factory = sqlite3.Row
	try:
		cursor = db.cursor()
		if user_id != None:
			query = '''SELECT * FROM activities WHERE user_id=?'''
			cursor.execute(query, (user_id,))
		else:
			query = '''SELECT * FROM activities'''
			cursor.execute(query)
		activities = cursor.fetchall()
		return activities
	except Exception as e:
		print(format("Couldn't retrieve activities. Message: %s" % (e,)))
		return []
	finally:
		db.close()

def get_users_with_current_activities():
	"""
	Get a list of all the IDs belonging to users who have activities starting
	or ending within the next 15 minutes.
	"""
	user_ids = []
	now = datetime.now().time()
	activities = get_activities()
	for activity in activities:
		st = datetime.strptime(activity["start_time"], "%Y-%m-%d %H:%M:%S")
		et = datetime.strptime(activity["end_time"], "%Y-%m-%d %H:%M:%S")
		margin = timedelta(minutes=15)
		if (st - margin).time() <= now and now <= (et + margin).time():
			print(activity["user_id"])
			user_ids.append(activity["user_id"])
	return user_ids

def delete_activity(id):
	"""
	Remove the activity with the given ID from the database.
	"""
	db = sqlite3.connect(DB_PATH)
	try:
		cursor = db.cursor()
		cursor.execute("DELETE FROM activities WHERE id=?", (id,))
		return True
	except Exception as e:
		print(format("Couldn't delete the activity with id=%d. Message: %s" 
			% (id, e)))
		return False
	finally:
		db.close()